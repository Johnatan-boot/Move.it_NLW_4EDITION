{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"C:\\\\nlw4designfinal\\\\moveit-2\\\\moveit-next\\\\src\\\\contexts\\\\countdownContext.tsx\";\nimport { Children, createContext, useContext, useEffect, useState } from \"react\";\nimport { ChallengesContext } from \"./ChallengesContext\";\nimport { CountdownProviderProps } from \"./CountdownProviderProps\";\nexport const CountdownContext = /*#__PURE__*/createContext({});\nlet countdownTimeout;\n/*Variavel tipagem global*/\n\n/*todo Contexto criado com typescript será criado neste modelo*/\n\nexport function CountdownProvider({\n  children\n}) {\n  const {\n    startNewChallenge\n  } = useContext(ChallengesContext);\n  const {\n    0: time,\n    1: seTime\n  } = useState(0.1 * 60);\n  const {\n    0: isActive,\n    1: setisActive\n  } = useState(false);\n  /*somnte estará ativo ao clicar no botão*/\n\n  const {\n    0: hasFinished,\n    1: setHasfinished\n  } = useState(false);\n  /*Estado que vai armazena se o Countdown está ativo ou não*/\n\n  /*inicializador do tempo do Countdown*/\n\n  const minutes = Math.floor(time / 60);\n  /*retorna valor baixo*/\n\n  const seconds = time % 60;\n\n  function startcountdown() {\n    /*Funcionalidade que reduz segundos e minutos*/\n    setisActive(true);\n  }\n\n  function resetCountdown() {\n    /*Funcionalidade que para o Countdown*/\n    clearTimeout(countdownTimeout);\n    /*Cancelando a Execução do Timeout*/\n\n    setisActive(false);\n    /*Apartir deste momento reseta o countdown ou zera*/\n\n    seTime(0.1 * 60);\n  }\n\n  useEffect(() => {\n    /*Dispara*/\n\n    /*o que eu quero executar? uma função que dispara efeitos*/\n    if (isActive && time > 0) {\n      countdownTimeout = setTimeout(() => {\n        /*  setTimeout=>Demora um segundo para Executar adciona um delay de 1 seg.*/\n        seTime(time - 1);\n        /*Reduz o tempo em segundo, e executa em apenas uma vez*/\n      }, 1000);\n      /*setTimeout => Algo aconteca depois de um tempo depois de 1000 eq. 1 seg.*/\n    } else if (isActive && time === 0) {\n      setHasfinished(true);\n      setisActive(false);\n      /*Quando  o Countdown Finaliar  chegar a 0 ele acabou, não está mais ativo*/\n\n      startNewChallenge();\n      /*funcionalidade quando o time chega em 0*/\n    }\n  }, [isActive, time\n  /*este parametro faz acontecer a magica*/\n  ]);\n  /*chamando a funcionalidade useEffect   2 parametros =>  1 como?{}, 2 quando? [],\r\n  [active] array de dependências*/\n\n  return /*#__PURE__*/_jsxDEV(CountdownContext.Provider, {\n    value: {\n      minutes,\n      seconds,\n      hasFinished,\n      isActive,\n      startcountdown,\n      resetCountdown\n    },\n    children: Children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 66,\n    columnNumber: 9\n  }, this);\n}","map":{"version":3,"sources":["C:/nlw4designfinal/moveit-2/moveit-next/src/contexts/countdownContext.tsx"],"names":["Children","createContext","useContext","useEffect","useState","ChallengesContext","CountdownProviderProps","CountdownContext","countdownTimeout","CountdownProvider","children","startNewChallenge","time","seTime","isActive","setisActive","hasFinished","setHasfinished","minutes","Math","floor","seconds","startcountdown","resetCountdown","clearTimeout","setTimeout"],"mappings":";;AACA,SAASA,QAAT,EAAmBC,aAAnB,EAAkCC,UAAlC,EAA8CC,SAA9C,EAAyDC,QAAzD,QAAyE,OAAzE;AACA,SAASC,iBAAT,QAAkC,qBAAlC;AACA,SAASC,sBAAT,QAAuC,0BAAvC;AAgBA,OAAO,MAAMC,gBAAgB,gBAAGN,aAAa,CAAC,EAAD,CAAtC;AAGP,IAAIO,gBAAJ;AAAyC;;AAGzC;;AACA,OAAO,SAASC,iBAAT,CAA2B;AAAEC,EAAAA;AAAF,CAA3B,EAAoF;AAEvF,QAAM;AAACC,IAAAA;AAAD,MAAsBT,UAAU,CAACG,iBAAD,CAAtC;AACA,QAAO;AAAA,OAACO,IAAD;AAAA,OAAOC;AAAP,MAAiBT,QAAQ,CAAC,MAAM,EAAP,CAAhC;AACA,QAAM;AAAA,OAACU,QAAD;AAAA,OAAWC;AAAX,MAAyBX,QAAQ,CAAC,KAAD,CAAvC;AAAmD;;AAClD,QAAM;AAAA,OAACY,WAAD;AAAA,OAAcC;AAAd,MAAgCb,QAAQ,CAAC,KAAD,CAA9C;AACD;;AAEC;;AACA,QAAMc,OAAO,GAAIC,IAAI,CAACC,KAAL,CAAWR,IAAI,GAAE,EAAjB,CAAjB;AAAwC;;AACxC,QAAMS,OAAO,GAAGT,IAAI,GAAG,EAAvB;;AAEA,WAASU,cAAT,GAA0B;AAAE;AACzBP,IAAAA,WAAW,CAAC,IAAD,CAAX;AAEA;;AAEJ,WAASQ,cAAT,GAA0B;AAAG;AAC3BC,IAAAA,YAAY,CAAChB,gBAAD,CAAZ;AAAgC;;AAChCO,IAAAA,WAAW,CAAC,KAAD,CAAX;AAAwB;;AAC1BF,IAAAA,MAAM,CAAC,MAAM,EAAP,CAAN;AAGC;;AAEEV,EAAAA,SAAS,CAAC,MAAM;AAAG;;AAAY;AAC7B,QAAGW,QAAQ,IAAIF,IAAI,GAAG,CAAtB,EAAyB;AACxBJ,MAAAA,gBAAgB,GAAGiB,UAAU,CAAC,MAAM;AAAI;AACrCZ,QAAAA,MAAM,CAACD,IAAI,GAAE,CAAP,CAAN;AAAgB;AACxB,OAFkC,EAEhC,IAFgC,CAA7B;AAEG;AACH,KAJD,MAIM,IAAIE,QAAQ,IAAIF,IAAI,KAAK,CAAzB,EAA4B;AACjCK,MAAAA,cAAc,CAAC,IAAD,CAAd;AACAF,MAAAA,WAAW,CAAC,KAAD,CAAX;AAAoB;;AACpBJ,MAAAA,iBAAiB;AAAM;AACvB;AACF,GAVQ,EAUP,CAACG,QAAD,EAAWF;AAAI;AAAf,GAVO,CAAT;AAUgE;AACvE;;AAEI,sBACI,QAAC,gBAAD,CAAkB,QAAlB;AAA2B,IAAA,KAAK,EAAE;AACjCM,MAAAA,OADiC;AAEjCG,MAAAA,OAFiC;AAGjCL,MAAAA,WAHiC;AAIjCF,MAAAA,QAJiC;AAKjCQ,MAAAA,cALiC;AAMjCC,MAAAA;AANiC,KAAlC;AAAA,cAUGvB;AAVH;AAAA;AAAA;AAAA;AAAA,UADJ;AAeH","sourcesContent":["import { ReactNode } from \"react\";\r\nimport { Children, createContext, useContext, useEffect, useState } from \"react\";\r\nimport { ChallengesContext } from \"./ChallengesContext\";\r\nimport { CountdownProviderProps } from \"./CountdownProviderProps\";\r\n\r\ninterface CountdownContextData {\r\n    minutes: number;          /*Dados retornados de dentro do Contexto*/\r\n    seconds: number;\r\n    hasFinished: boolean;\r\n    isActive: boolean;\r\n    startcountdown: ()=> void;\r\n    resetCountdown: ()=> void;\r\n                  \r\n}\r\ninterface CountdownProviderProps {\r\n    children: ReactNode;\r\n}\r\n\r\n\r\nexport const CountdownContext = createContext({} as CountdownContextData)\r\n\r\n\r\nlet countdownTimeout: NodeJS.Timeout;    /*Variavel tipagem global*/\r\n\r\n\r\n/*todo Contexto criado com typescript será criado neste modelo*/\r\nexport function CountdownProvider({ children }: /*propriedades=>*/ CountdownProviderProps) {\r\n\r\n    const {startNewChallenge} = useContext(ChallengesContext);\r\n    const  [time, seTime] = useState(0.1 * 60);\r\n    const [isActive, setisActive] =useState(false);    /*somnte estará ativo ao clicar no botão*/\r\n     const [hasFinished, setHasfinished] = useState(false);\r\n    /*Estado que vai armazena se o Countdown está ativo ou não*/\r\n  \r\n     /*inicializador do tempo do Countdown*/\r\n     const minutes =  Math.floor(time /60);  /*retorna valor baixo*/\r\n     const seconds = time % 60;\r\n     \r\n     function startcountdown() { /*Funcionalidade que reduz segundos e minutos*/\r\n        setisActive(true);\r\n    \r\n       }\r\n    \r\n    function resetCountdown() {  /*Funcionalidade que para o Countdown*/\r\n      clearTimeout(countdownTimeout); /*Cancelando a Execução do Timeout*/\r\n      setisActive(false);     /*Apartir deste momento reseta o countdown ou zera*/\r\n    seTime(0.1 * 60);\r\n    \r\n    \r\n    }\r\n    \r\n       useEffect(() => {  /*Dispara*/ /*o que eu quero executar? uma função que dispara efeitos*/\r\n         if(isActive && time > 0) {\r\n          countdownTimeout = setTimeout(() => {   /*  setTimeout=>Demora um segundo para Executar adciona um delay de 1 seg.*/\r\n             seTime(time -1) /*Reduz o tempo em segundo, e executa em apenas uma vez*/\r\n    }, 1000) /*setTimeout => Algo aconteca depois de um tempo depois de 1000 eq. 1 seg.*/ \r\n         }else if (isActive && time === 0) {\r\n          setHasfinished(true);\r\n          setisActive(false); /*Quando  o Countdown Finaliar  chegar a 0 ele acabou, não está mais ativo*/\r\n          startNewChallenge();   /*funcionalidade quando o time chega em 0*/\r\n         }\r\n       },[isActive, time/*este parametro faz acontecer a magica*/])    /*chamando a funcionalidade useEffect   2 parametros =>  1 como?{}, 2 quando? [],\r\n        [active] array de dependências*/\r\n\r\n    return (\r\n        <CountdownContext.Provider value={{\r\n         minutes,\r\n         seconds,\r\n         hasFinished,\r\n         isActive,\r\n         startcountdown,\r\n         resetCountdown,\r\n\r\n        }}>\r\n\r\n          {Children}  \r\n        </CountdownContext.Provider >\r\n    )\r\n\r\n}"]},"metadata":{},"sourceType":"module"}